Original Problem: https://leetcode.com/problems/binary-tree-paths/submissions/
257. Binary Tree Paths [EASY]
Given a binary tree, return all root-to-leaf paths.

<My Solution>
Runtime: 18 ms, faster than 6.69% of Java online submissions for Binary Tree Paths.
Memory Usage: 40.5 MB, less than 8.32% of Java online submissions for Binary Tree Paths.class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        
        List<String> li = new ArrayList();

        if(root==null){
            return li;
        }
        String s = "";
        
        helper(root, s, li);
        
        
        
        return li;
        
    }
    
    
    public String helper(TreeNode root, String s, List<String> li){
        
        
       if(s.equals("")){
           s+=root.val;
       } else{
           s=s+"->"+root.val;
       }
        
       if(root.left==null && root.right==null){
            li.add(s);
            s="";
        } 
        
        else{
            if(root.left!=null){
                helper(root.left, s,li);
            } 
        
            if(root.right!=null){
                helper(root.right, s,li);
            } 
        
        }
        
        return s;

        

        
        
    }
        
    }
    
    
    
    <Optimized Solution>
    source: https://www.programcreek.com/2014/05/leetcode-binary-tree-paths-java/
    Runtime: 6 ms, faster than 65.60% of Java online submissions for Binary Tree Paths.
    Memory Usage: 40 MB, less than 25.84% of Java online submissions for Binary Tree Paths.
    public List<String> binaryTreePaths(TreeNode root) {
    ArrayList<String> finalResult = new ArrayList<String>();
 
    if(root==null)
        return finalResult;
 
    ArrayList<String> curr = new ArrayList<String>();
    ArrayList<ArrayList<String>> results = new ArrayList<ArrayList<String>>();
 
    dfs(root, results, curr);
 
    for(ArrayList<String> al : results){
        StringBuilder sb = new StringBuilder();
        sb.append(al.get(0));
        for(int i=1; i<al.size();i++){
            sb.append("->"+al.get(i));
        }
 
        finalResult.add(sb.toString());
    }
 
    return finalResult;
}
 
public void dfs(TreeNode root, ArrayList<ArrayList<String>> list, ArrayList<String> curr){
    curr.add(String.valueOf(root.val));
 
    if(root.left==null && root.right==null){
        list.add(curr);
        return;
    }
 
    if(root.left!=null){
        ArrayList<String> temp = new ArrayList<String>(curr);
        dfs(root.left, list, temp);
    }
 
    if(root.right!=null){
        ArrayList<String> temp = new ArrayList<String>(curr);
        dfs(root.right, list, temp);
    } 
    
    
    
    
<Optimized Solution 2: simplified dfs>
source :https://www.programcreek.com/2014/05/leetcode-binary-tree-paths-java/
Runtime: 10 ms, faster than 23.65% of Java online submissions for Binary Tree Paths.
Memory Usage: 40.5 MB, less than 9.05% of Java online submissions for Binary Tree Paths.
/*Simplified, but slower*/

    public List<String> binaryTreePaths(TreeNode root) {
 
    String sb = "";
    ArrayList<String> result = new ArrayList<String>();
 
    helper(root, result, sb);
 
    return result;
}
 
public void helper(TreeNode root, ArrayList<String> result, String s){
    if(root==null){
        return;
    }
 
    s = s+"->"+root.val;
 
    if(root.left==null &&root.right==null){
        result.add(s.substring(2));
        return;
    }
 
    if(root.left!=null){
        helper(root.left, result, s);
    }
    if(root.right!=null){
        helper(root.right, result, s);
    }
}
